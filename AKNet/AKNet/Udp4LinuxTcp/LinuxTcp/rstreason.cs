/************************************Copyright*****************************************
*        ProjectName:AKNet
*        Web:https://github.com/825126369/AKNet
*        Description:这是一个面向 .Net Standard 2.1 的游戏网络库
*        Author:阿珂
*        ModifyTime:2025/2/27 22:28:11
*        Copyright:MIT软件许可证
************************************Copyright*****************************************/
namespace AKNet.Udp4LinuxTcp.Common
{
    //TCP RST（Reset）报文是 TCP 协议中的一种控制报文，用于重置一个 TCP 连接。
    //当 TCP 连接出现某些问题，或者需要强制关闭连接时，RST 报文会被发送。
    //接收到 RST 报文的一方会立即终止连接，并释放所有相关的资源
    //用于表示发送 TCP 重置（RST）报文的原因
    public enum sk_rst_reason
    {
        /* Refer to include/net/dropreason-core.h
         * Rely on skb drop reasons because it indicates exactly why RST
         * could happen.
         */
        /** @SK_RST_REASON_NOT_SPECIFIED: reset reason is not specified */
        SK_RST_REASON_NOT_SPECIFIED,
        /** @SK_RST_REASON_NO_SOCKET: no valid socket that can be used */
        SK_RST_REASON_NO_SOCKET,
        /**
         * @SK_RST_REASON_TCP_INVALID_ACK_SEQUENCE: Not acceptable ACK SEQ
         * field because ack sequence is not in the window between snd_una
         * and snd_nxt
         */
        SK_RST_REASON_TCP_INVALID_ACK_SEQUENCE,
        /**
         * @SK_RST_REASON_TCP_RFC7323_PAWS: PAWS check, corresponding to
         * LINUX_MIB_PAWSESTABREJECTED, LINUX_MIB_PAWSACTIVEREJECTED
         */
        SK_RST_REASON_TCP_RFC7323_PAWS,
        /** @SK_RST_REASON_TCP_TOO_OLD_ACK: TCP ACK is too old */
        SK_RST_REASON_TCP_TOO_OLD_ACK,
        /**
         * @SK_RST_REASON_TCP_ACK_UNSENT_DATA: TCP ACK for data we haven't
         * sent yet
         */
        SK_RST_REASON_TCP_ACK_UNSENT_DATA,
        /** @SK_RST_REASON_TCP_FLAGS: TCP flags invalid */
        SK_RST_REASON_TCP_FLAGS,
        /** @SK_RST_REASON_TCP_OLD_ACK: TCP ACK is old, but in window */
        SK_RST_REASON_TCP_OLD_ACK,
        /**
         * @SK_RST_REASON_TCP_ABORT_ON_DATA: abort on data
         * corresponding to LINUX_MIB_TCPABORTONDATA
         */
        SK_RST_REASON_TCP_ABORT_ON_DATA,

        /* Here start with the independent reasons */
        /** @SK_RST_REASON_TCP_TIMEWAIT_SOCKET: happen on the timewait socket */
        SK_RST_REASON_TCP_TIMEWAIT_SOCKET,
        /**
         * @SK_RST_REASON_INVALID_SYN: receive bad syn packet
         * RFC 793 says if the state is not CLOSED/LISTEN/SYN-SENT then
         * "fourth, check the SYN bit,...If the SYN is in the window it is
         * an error, send a reset"
         */
        SK_RST_REASON_INVALID_SYN,
        /**
         * @SK_RST_REASON_TCP_ABORT_ON_CLOSE: abort on close
         * corresponding to LINUX_MIB_TCPABORTONCLOSE
         */
        SK_RST_REASON_TCP_ABORT_ON_CLOSE,
        /**
         * @SK_RST_REASON_TCP_ABORT_ON_LINGER: abort on linger
         * corresponding to LINUX_MIB_TCPABORTONLINGER
         */
        SK_RST_REASON_TCP_ABORT_ON_LINGER,
        /**
         * @SK_RST_REASON_TCP_ABORT_ON_MEMORY: abort on memory
         * corresponding to LINUX_MIB_TCPABORTONMEMORY
         */
        SK_RST_REASON_TCP_ABORT_ON_MEMORY,
        /**
         * @SK_RST_REASON_TCP_STATE: abort on tcp state
         * Please see RFC 9293 for all possible reset conditions
         */
        SK_RST_REASON_TCP_STATE,
        /**
         * @SK_RST_REASON_TCP_KEEPALIVE_TIMEOUT: time to timeout
         * When we have already run out of all the chances, which means
         * keepalive timeout, we have to reset the connection
         */
        SK_RST_REASON_TCP_KEEPALIVE_TIMEOUT,
        /**
         * @SK_RST_REASON_TCP_DISCONNECT_WITH_DATA: disconnect when write
         * queue is not empty
         * It means user has written data into the write queue when doing
         * disconnecting, so we have to send an RST.
         */
        SK_RST_REASON_TCP_DISCONNECT_WITH_DATA,

        /* Copy from include/uapi/linux/mptcp.h.
         * These reset fields will not be changed since they adhere to
         * RFC 8684. So do not touch them. I'm going to list each definition
         * of them respectively.
         */
        /**
         * @SK_RST_REASON_MPTCP_RST_EUNSPEC: Unspecified error.
         * This is the default error; it implies that the subflow is no
         * longer available. The presence of this option shows that the
         * RST was generated by an MPTCP-aware device.
         */
        SK_RST_REASON_MPTCP_RST_EUNSPEC,
        /**
         * @SK_RST_REASON_MPTCP_RST_EMPTCP: MPTCP-specific error.
         * An error has been detected in the processing of MPTCP options.
         * This is the usual reason code to return in the cases where a RST
         * is being sent to close a subflow because of an invalid response.
         */
        SK_RST_REASON_MPTCP_RST_EMPTCP,
        /**
         * @SK_RST_REASON_MPTCP_RST_ERESOURCE: Lack of resources.
         * This code indicates that the sending host does not have enough
         * resources to support the terminated subflow.
         */
        SK_RST_REASON_MPTCP_RST_ERESOURCE,
        /**
         * @SK_RST_REASON_MPTCP_RST_EPROHIBIT: Administratively prohibited.
         * This code indicates that the requested subflow is prohibited by
         * the policies of the sending host.
         */
        SK_RST_REASON_MPTCP_RST_EPROHIBIT,
        /**
         * @SK_RST_REASON_MPTCP_RST_EWQ2BIG: Too much outstanding data.
         * This code indicates that there is an excessive amount of data
         * that needs to be transmitted over the terminated subflow while
         * having already been acknowledged over one or more other subflows.
         * This may occur if a path has been unavailable for a short period
         * and it is more efficient to reset and start again than it is to
         * retransmit the queued data.
         */
        SK_RST_REASON_MPTCP_RST_EWQ2BIG,
        /**
         * @SK_RST_REASON_MPTCP_RST_EBADPERF: Unacceptable performance.
         * This code indicates that the performance of this subflow was
         * too low compared to the other subflows of this Multipath TCP
         * connection.
         */
        SK_RST_REASON_MPTCP_RST_EBADPERF,
        /**
         * @SK_RST_REASON_MPTCP_RST_EMIDDLEBOX: Middlebox interference.
         * Middlebox interference has been detected over this subflow,
         * making MPTCP signaling invalid. For example, this may be sent
         * if the checksum does not validate.
         */
        SK_RST_REASON_MPTCP_RST_EMIDDLEBOX,

        /** @SK_RST_REASON_ERROR: unexpected error happens */
        SK_RST_REASON_ERROR,

        /**
         * @SK_RST_REASON_MAX: Maximum of socket reset reasons.
         * It shouldn't be used as a real 'reason'.
         */
        SK_RST_REASON_MAX,
    };

}
